// Code generated by counterfeiter. DO NOT EDIT.
package mixpanelfakes

import (
	"sync"

	"nanomsg.org/go/mangos/v2"
)

// FakeSocket ...
type FakeSocket struct {
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	DialStub        func(string) error
	dialMutex       sync.RWMutex
	dialArgsForCall []struct {
		arg1 string
	}
	dialReturns struct {
		result1 error
	}
	dialReturnsOnCall map[int]struct {
		result1 error
	}
	DialOptionsStub        func(string, map[string]interface{}) error
	dialOptionsMutex       sync.RWMutex
	dialOptionsArgsForCall []struct {
		arg1 string
		arg2 map[string]interface{}
	}
	dialOptionsReturns struct {
		result1 error
	}
	dialOptionsReturnsOnCall map[int]struct {
		result1 error
	}
	GetOptionStub        func(string) (interface{}, error)
	getOptionMutex       sync.RWMutex
	getOptionArgsForCall []struct {
		arg1 string
	}
	getOptionReturns struct {
		result1 interface{}
		result2 error
	}
	getOptionReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	InfoStub        func() mangos.ProtocolInfo
	infoMutex       sync.RWMutex
	infoArgsForCall []struct {
	}
	infoReturns struct {
		result1 mangos.ProtocolInfo
	}
	infoReturnsOnCall map[int]struct {
		result1 mangos.ProtocolInfo
	}
	ListenStub        func(string) error
	listenMutex       sync.RWMutex
	listenArgsForCall []struct {
		arg1 string
	}
	listenReturns struct {
		result1 error
	}
	listenReturnsOnCall map[int]struct {
		result1 error
	}
	ListenOptionsStub        func(string, map[string]interface{}) error
	listenOptionsMutex       sync.RWMutex
	listenOptionsArgsForCall []struct {
		arg1 string
		arg2 map[string]interface{}
	}
	listenOptionsReturns struct {
		result1 error
	}
	listenOptionsReturnsOnCall map[int]struct {
		result1 error
	}
	NewDialerStub        func(string, map[string]interface{}) (mangos.Dialer, error)
	newDialerMutex       sync.RWMutex
	newDialerArgsForCall []struct {
		arg1 string
		arg2 map[string]interface{}
	}
	newDialerReturns struct {
		result1 mangos.Dialer
		result2 error
	}
	newDialerReturnsOnCall map[int]struct {
		result1 mangos.Dialer
		result2 error
	}
	NewListenerStub        func(string, map[string]interface{}) (mangos.Listener, error)
	newListenerMutex       sync.RWMutex
	newListenerArgsForCall []struct {
		arg1 string
		arg2 map[string]interface{}
	}
	newListenerReturns struct {
		result1 mangos.Listener
		result2 error
	}
	newListenerReturnsOnCall map[int]struct {
		result1 mangos.Listener
		result2 error
	}
	OpenContextStub        func() (mangos.Context, error)
	openContextMutex       sync.RWMutex
	openContextArgsForCall []struct {
	}
	openContextReturns struct {
		result1 mangos.Context
		result2 error
	}
	openContextReturnsOnCall map[int]struct {
		result1 mangos.Context
		result2 error
	}
	RecvStub        func() ([]byte, error)
	recvMutex       sync.RWMutex
	recvArgsForCall []struct {
	}
	recvReturns struct {
		result1 []byte
		result2 error
	}
	recvReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	RecvMsgStub        func() (*mangos.Message, error)
	recvMsgMutex       sync.RWMutex
	recvMsgArgsForCall []struct {
	}
	recvMsgReturns struct {
		result1 *mangos.Message
		result2 error
	}
	recvMsgReturnsOnCall map[int]struct {
		result1 *mangos.Message
		result2 error
	}
	SendStub        func([]byte) error
	sendMutex       sync.RWMutex
	sendArgsForCall []struct {
		arg1 []byte
	}
	sendReturns struct {
		result1 error
	}
	sendReturnsOnCall map[int]struct {
		result1 error
	}
	SendMsgStub        func(*mangos.Message) error
	sendMsgMutex       sync.RWMutex
	sendMsgArgsForCall []struct {
		arg1 *mangos.Message
	}
	sendMsgReturns struct {
		result1 error
	}
	sendMsgReturnsOnCall map[int]struct {
		result1 error
	}
	SetOptionStub        func(string, interface{}) error
	setOptionMutex       sync.RWMutex
	setOptionArgsForCall []struct {
		arg1 string
		arg2 interface{}
	}
	setOptionReturns struct {
		result1 error
	}
	setOptionReturnsOnCall map[int]struct {
		result1 error
	}
	SetPipeEventHookStub        func(mangos.PipeEventHook) mangos.PipeEventHook
	setPipeEventHookMutex       sync.RWMutex
	setPipeEventHookArgsForCall []struct {
		arg1 mangos.PipeEventHook
	}
	setPipeEventHookReturns struct {
		result1 mangos.PipeEventHook
	}
	setPipeEventHookReturnsOnCall map[int]struct {
		result1 mangos.PipeEventHook
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

// Close ...
func (fake *FakeSocket) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		return fake.CloseStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.closeReturns
	return fakeReturns.result1
}

// CloseCallCount ...
func (fake *FakeSocket) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

// CloseCalls ...
func (fake *FakeSocket) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

// CloseReturns ...
func (fake *FakeSocket) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

// CloseReturnsOnCall ...
func (fake *FakeSocket) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

// Dial ...
func (fake *FakeSocket) Dial(arg1 string) error {
	fake.dialMutex.Lock()
	ret, specificReturn := fake.dialReturnsOnCall[len(fake.dialArgsForCall)]
	fake.dialArgsForCall = append(fake.dialArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Dial", []interface{}{arg1})
	fake.dialMutex.Unlock()
	if fake.DialStub != nil {
		return fake.DialStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.dialReturns
	return fakeReturns.result1
}

// DialCallCount ...
func (fake *FakeSocket) DialCallCount() int {
	fake.dialMutex.RLock()
	defer fake.dialMutex.RUnlock()
	return len(fake.dialArgsForCall)
}

// DialCalls ...
func (fake *FakeSocket) DialCalls(stub func(string) error) {
	fake.dialMutex.Lock()
	defer fake.dialMutex.Unlock()
	fake.DialStub = stub
}

// DialArgsForCall ...
func (fake *FakeSocket) DialArgsForCall(i int) string {
	fake.dialMutex.RLock()
	defer fake.dialMutex.RUnlock()
	argsForCall := fake.dialArgsForCall[i]
	return argsForCall.arg1
}

// DialReturns ...
func (fake *FakeSocket) DialReturns(result1 error) {
	fake.dialMutex.Lock()
	defer fake.dialMutex.Unlock()
	fake.DialStub = nil
	fake.dialReturns = struct {
		result1 error
	}{result1}
}

// DialReturnsOnCall ...
func (fake *FakeSocket) DialReturnsOnCall(i int, result1 error) {
	fake.dialMutex.Lock()
	defer fake.dialMutex.Unlock()
	fake.DialStub = nil
	if fake.dialReturnsOnCall == nil {
		fake.dialReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.dialReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

// DialOptions ...
func (fake *FakeSocket) DialOptions(arg1 string, arg2 map[string]interface{}) error {
	fake.dialOptionsMutex.Lock()
	ret, specificReturn := fake.dialOptionsReturnsOnCall[len(fake.dialOptionsArgsForCall)]
	fake.dialOptionsArgsForCall = append(fake.dialOptionsArgsForCall, struct {
		arg1 string
		arg2 map[string]interface{}
	}{arg1, arg2})
	fake.recordInvocation("DialOptions", []interface{}{arg1, arg2})
	fake.dialOptionsMutex.Unlock()
	if fake.DialOptionsStub != nil {
		return fake.DialOptionsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.dialOptionsReturns
	return fakeReturns.result1
}

// DialOptionsCallCount ...
func (fake *FakeSocket) DialOptionsCallCount() int {
	fake.dialOptionsMutex.RLock()
	defer fake.dialOptionsMutex.RUnlock()
	return len(fake.dialOptionsArgsForCall)
}

// DialOptionsCalls ...
func (fake *FakeSocket) DialOptionsCalls(stub func(string, map[string]interface{}) error) {
	fake.dialOptionsMutex.Lock()
	defer fake.dialOptionsMutex.Unlock()
	fake.DialOptionsStub = stub
}

// DialOptionsArgsForCall ...
func (fake *FakeSocket) DialOptionsArgsForCall(i int) (string, map[string]interface{}) {
	fake.dialOptionsMutex.RLock()
	defer fake.dialOptionsMutex.RUnlock()
	argsForCall := fake.dialOptionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

// DialOptionsReturns ...
func (fake *FakeSocket) DialOptionsReturns(result1 error) {
	fake.dialOptionsMutex.Lock()
	defer fake.dialOptionsMutex.Unlock()
	fake.DialOptionsStub = nil
	fake.dialOptionsReturns = struct {
		result1 error
	}{result1}
}

// DialOptionsReturnsOnCall ...
func (fake *FakeSocket) DialOptionsReturnsOnCall(i int, result1 error) {
	fake.dialOptionsMutex.Lock()
	defer fake.dialOptionsMutex.Unlock()
	fake.DialOptionsStub = nil
	if fake.dialOptionsReturnsOnCall == nil {
		fake.dialOptionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.dialOptionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

// GetOption ...
func (fake *FakeSocket) GetOption(arg1 string) (interface{}, error) {
	fake.getOptionMutex.Lock()
	ret, specificReturn := fake.getOptionReturnsOnCall[len(fake.getOptionArgsForCall)]
	fake.getOptionArgsForCall = append(fake.getOptionArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetOption", []interface{}{arg1})
	fake.getOptionMutex.Unlock()
	if fake.GetOptionStub != nil {
		return fake.GetOptionStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getOptionReturns
	return fakeReturns.result1, fakeReturns.result2
}

// GetOptionCallCount ...
func (fake *FakeSocket) GetOptionCallCount() int {
	fake.getOptionMutex.RLock()
	defer fake.getOptionMutex.RUnlock()
	return len(fake.getOptionArgsForCall)
}

// GetOptionCalls ...
func (fake *FakeSocket) GetOptionCalls(stub func(string) (interface{}, error)) {
	fake.getOptionMutex.Lock()
	defer fake.getOptionMutex.Unlock()
	fake.GetOptionStub = stub
}

// GetOptionArgsForCall ...
func (fake *FakeSocket) GetOptionArgsForCall(i int) string {
	fake.getOptionMutex.RLock()
	defer fake.getOptionMutex.RUnlock()
	argsForCall := fake.getOptionArgsForCall[i]
	return argsForCall.arg1
}

// GetOptionReturns ...
func (fake *FakeSocket) GetOptionReturns(result1 interface{}, result2 error) {
	fake.getOptionMutex.Lock()
	defer fake.getOptionMutex.Unlock()
	fake.GetOptionStub = nil
	fake.getOptionReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

// GetOptionReturnsOnCall ...
func (fake *FakeSocket) GetOptionReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.getOptionMutex.Lock()
	defer fake.getOptionMutex.Unlock()
	fake.GetOptionStub = nil
	if fake.getOptionReturnsOnCall == nil {
		fake.getOptionReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.getOptionReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

// Info ...
func (fake *FakeSocket) Info() mangos.ProtocolInfo {
	fake.infoMutex.Lock()
	ret, specificReturn := fake.infoReturnsOnCall[len(fake.infoArgsForCall)]
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct {
	}{})
	fake.recordInvocation("Info", []interface{}{})
	fake.infoMutex.Unlock()
	if fake.InfoStub != nil {
		return fake.InfoStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.infoReturns
	return fakeReturns.result1
}

// InfoCallCount ...
func (fake *FakeSocket) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

// InfoCalls ...
func (fake *FakeSocket) InfoCalls(stub func() mangos.ProtocolInfo) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = stub
}

// InfoReturns ...
func (fake *FakeSocket) InfoReturns(result1 mangos.ProtocolInfo) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	fake.infoReturns = struct {
		result1 mangos.ProtocolInfo
	}{result1}
}

// InfoReturnsOnCall ...
func (fake *FakeSocket) InfoReturnsOnCall(i int, result1 mangos.ProtocolInfo) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	if fake.infoReturnsOnCall == nil {
		fake.infoReturnsOnCall = make(map[int]struct {
			result1 mangos.ProtocolInfo
		})
	}
	fake.infoReturnsOnCall[i] = struct {
		result1 mangos.ProtocolInfo
	}{result1}
}

// Listen ...
func (fake *FakeSocket) Listen(arg1 string) error {
	fake.listenMutex.Lock()
	ret, specificReturn := fake.listenReturnsOnCall[len(fake.listenArgsForCall)]
	fake.listenArgsForCall = append(fake.listenArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Listen", []interface{}{arg1})
	fake.listenMutex.Unlock()
	if fake.ListenStub != nil {
		return fake.ListenStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.listenReturns
	return fakeReturns.result1
}

// ListenCallCount ...
func (fake *FakeSocket) ListenCallCount() int {
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	return len(fake.listenArgsForCall)
}

// ListenCalls ...
func (fake *FakeSocket) ListenCalls(stub func(string) error) {
	fake.listenMutex.Lock()
	defer fake.listenMutex.Unlock()
	fake.ListenStub = stub
}

// ListenArgsForCall ...
func (fake *FakeSocket) ListenArgsForCall(i int) string {
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	argsForCall := fake.listenArgsForCall[i]
	return argsForCall.arg1
}

// ListenReturns ...
func (fake *FakeSocket) ListenReturns(result1 error) {
	fake.listenMutex.Lock()
	defer fake.listenMutex.Unlock()
	fake.ListenStub = nil
	fake.listenReturns = struct {
		result1 error
	}{result1}
}

// ListenReturnsOnCall ...
func (fake *FakeSocket) ListenReturnsOnCall(i int, result1 error) {
	fake.listenMutex.Lock()
	defer fake.listenMutex.Unlock()
	fake.ListenStub = nil
	if fake.listenReturnsOnCall == nil {
		fake.listenReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listenReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

// ListenOptions ...
func (fake *FakeSocket) ListenOptions(arg1 string, arg2 map[string]interface{}) error {
	fake.listenOptionsMutex.Lock()
	ret, specificReturn := fake.listenOptionsReturnsOnCall[len(fake.listenOptionsArgsForCall)]
	fake.listenOptionsArgsForCall = append(fake.listenOptionsArgsForCall, struct {
		arg1 string
		arg2 map[string]interface{}
	}{arg1, arg2})
	fake.recordInvocation("ListenOptions", []interface{}{arg1, arg2})
	fake.listenOptionsMutex.Unlock()
	if fake.ListenOptionsStub != nil {
		return fake.ListenOptionsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.listenOptionsReturns
	return fakeReturns.result1
}

// ListenOptionsCallCount ...
func (fake *FakeSocket) ListenOptionsCallCount() int {
	fake.listenOptionsMutex.RLock()
	defer fake.listenOptionsMutex.RUnlock()
	return len(fake.listenOptionsArgsForCall)
}

// ListenOptionsCalls ...
func (fake *FakeSocket) ListenOptionsCalls(stub func(string, map[string]interface{}) error) {
	fake.listenOptionsMutex.Lock()
	defer fake.listenOptionsMutex.Unlock()
	fake.ListenOptionsStub = stub
}

// ListenOptionsArgsForCall ...
func (fake *FakeSocket) ListenOptionsArgsForCall(i int) (string, map[string]interface{}) {
	fake.listenOptionsMutex.RLock()
	defer fake.listenOptionsMutex.RUnlock()
	argsForCall := fake.listenOptionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

// ListenOptionsReturns ...
func (fake *FakeSocket) ListenOptionsReturns(result1 error) {
	fake.listenOptionsMutex.Lock()
	defer fake.listenOptionsMutex.Unlock()
	fake.ListenOptionsStub = nil
	fake.listenOptionsReturns = struct {
		result1 error
	}{result1}
}

// ListenOptionsReturnsOnCall ...
func (fake *FakeSocket) ListenOptionsReturnsOnCall(i int, result1 error) {
	fake.listenOptionsMutex.Lock()
	defer fake.listenOptionsMutex.Unlock()
	fake.ListenOptionsStub = nil
	if fake.listenOptionsReturnsOnCall == nil {
		fake.listenOptionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listenOptionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

// NewDialer ...
func (fake *FakeSocket) NewDialer(arg1 string, arg2 map[string]interface{}) (mangos.Dialer, error) {
	fake.newDialerMutex.Lock()
	ret, specificReturn := fake.newDialerReturnsOnCall[len(fake.newDialerArgsForCall)]
	fake.newDialerArgsForCall = append(fake.newDialerArgsForCall, struct {
		arg1 string
		arg2 map[string]interface{}
	}{arg1, arg2})
	fake.recordInvocation("NewDialer", []interface{}{arg1, arg2})
	fake.newDialerMutex.Unlock()
	if fake.NewDialerStub != nil {
		return fake.NewDialerStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.newDialerReturns
	return fakeReturns.result1, fakeReturns.result2
}

// NewDialerCallCount ...
func (fake *FakeSocket) NewDialerCallCount() int {
	fake.newDialerMutex.RLock()
	defer fake.newDialerMutex.RUnlock()
	return len(fake.newDialerArgsForCall)
}

// NewDialerCalls ...
func (fake *FakeSocket) NewDialerCalls(stub func(string, map[string]interface{}) (mangos.Dialer, error)) {
	fake.newDialerMutex.Lock()
	defer fake.newDialerMutex.Unlock()
	fake.NewDialerStub = stub
}

// NewDialerArgsForCall ...
func (fake *FakeSocket) NewDialerArgsForCall(i int) (string, map[string]interface{}) {
	fake.newDialerMutex.RLock()
	defer fake.newDialerMutex.RUnlock()
	argsForCall := fake.newDialerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

// NewDialerReturns ...
func (fake *FakeSocket) NewDialerReturns(result1 mangos.Dialer, result2 error) {
	fake.newDialerMutex.Lock()
	defer fake.newDialerMutex.Unlock()
	fake.NewDialerStub = nil
	fake.newDialerReturns = struct {
		result1 mangos.Dialer
		result2 error
	}{result1, result2}
}

// NewDialerReturnsOnCall ...
func (fake *FakeSocket) NewDialerReturnsOnCall(i int, result1 mangos.Dialer, result2 error) {
	fake.newDialerMutex.Lock()
	defer fake.newDialerMutex.Unlock()
	fake.NewDialerStub = nil
	if fake.newDialerReturnsOnCall == nil {
		fake.newDialerReturnsOnCall = make(map[int]struct {
			result1 mangos.Dialer
			result2 error
		})
	}
	fake.newDialerReturnsOnCall[i] = struct {
		result1 mangos.Dialer
		result2 error
	}{result1, result2}
}

// NewListener ...
func (fake *FakeSocket) NewListener(arg1 string, arg2 map[string]interface{}) (mangos.Listener, error) {
	fake.newListenerMutex.Lock()
	ret, specificReturn := fake.newListenerReturnsOnCall[len(fake.newListenerArgsForCall)]
	fake.newListenerArgsForCall = append(fake.newListenerArgsForCall, struct {
		arg1 string
		arg2 map[string]interface{}
	}{arg1, arg2})
	fake.recordInvocation("NewListener", []interface{}{arg1, arg2})
	fake.newListenerMutex.Unlock()
	if fake.NewListenerStub != nil {
		return fake.NewListenerStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.newListenerReturns
	return fakeReturns.result1, fakeReturns.result2
}

// NewListenerCallCount ...
func (fake *FakeSocket) NewListenerCallCount() int {
	fake.newListenerMutex.RLock()
	defer fake.newListenerMutex.RUnlock()
	return len(fake.newListenerArgsForCall)
}

// NewListenerCalls ...
func (fake *FakeSocket) NewListenerCalls(stub func(string, map[string]interface{}) (mangos.Listener, error)) {
	fake.newListenerMutex.Lock()
	defer fake.newListenerMutex.Unlock()
	fake.NewListenerStub = stub
}

// NewListenerArgsForCall ...
func (fake *FakeSocket) NewListenerArgsForCall(i int) (string, map[string]interface{}) {
	fake.newListenerMutex.RLock()
	defer fake.newListenerMutex.RUnlock()
	argsForCall := fake.newListenerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

// NewListenerReturns ...
func (fake *FakeSocket) NewListenerReturns(result1 mangos.Listener, result2 error) {
	fake.newListenerMutex.Lock()
	defer fake.newListenerMutex.Unlock()
	fake.NewListenerStub = nil
	fake.newListenerReturns = struct {
		result1 mangos.Listener
		result2 error
	}{result1, result2}
}

// NewListenerReturnsOnCall ...
func (fake *FakeSocket) NewListenerReturnsOnCall(i int, result1 mangos.Listener, result2 error) {
	fake.newListenerMutex.Lock()
	defer fake.newListenerMutex.Unlock()
	fake.NewListenerStub = nil
	if fake.newListenerReturnsOnCall == nil {
		fake.newListenerReturnsOnCall = make(map[int]struct {
			result1 mangos.Listener
			result2 error
		})
	}
	fake.newListenerReturnsOnCall[i] = struct {
		result1 mangos.Listener
		result2 error
	}{result1, result2}
}

// OpenContext ...
func (fake *FakeSocket) OpenContext() (mangos.Context, error) {
	fake.openContextMutex.Lock()
	ret, specificReturn := fake.openContextReturnsOnCall[len(fake.openContextArgsForCall)]
	fake.openContextArgsForCall = append(fake.openContextArgsForCall, struct {
	}{})
	fake.recordInvocation("OpenContext", []interface{}{})
	fake.openContextMutex.Unlock()
	if fake.OpenContextStub != nil {
		return fake.OpenContextStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.openContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

// OpenContextCallCount ...
func (fake *FakeSocket) OpenContextCallCount() int {
	fake.openContextMutex.RLock()
	defer fake.openContextMutex.RUnlock()
	return len(fake.openContextArgsForCall)
}

// OpenContextCalls ...
func (fake *FakeSocket) OpenContextCalls(stub func() (mangos.Context, error)) {
	fake.openContextMutex.Lock()
	defer fake.openContextMutex.Unlock()
	fake.OpenContextStub = stub
}

// OpenContextReturns ...
func (fake *FakeSocket) OpenContextReturns(result1 mangos.Context, result2 error) {
	fake.openContextMutex.Lock()
	defer fake.openContextMutex.Unlock()
	fake.OpenContextStub = nil
	fake.openContextReturns = struct {
		result1 mangos.Context
		result2 error
	}{result1, result2}
}

// OpenContextReturnsOnCall ...
func (fake *FakeSocket) OpenContextReturnsOnCall(i int, result1 mangos.Context, result2 error) {
	fake.openContextMutex.Lock()
	defer fake.openContextMutex.Unlock()
	fake.OpenContextStub = nil
	if fake.openContextReturnsOnCall == nil {
		fake.openContextReturnsOnCall = make(map[int]struct {
			result1 mangos.Context
			result2 error
		})
	}
	fake.openContextReturnsOnCall[i] = struct {
		result1 mangos.Context
		result2 error
	}{result1, result2}
}

// Recv ...
func (fake *FakeSocket) Recv() ([]byte, error) {
	fake.recvMutex.Lock()
	ret, specificReturn := fake.recvReturnsOnCall[len(fake.recvArgsForCall)]
	fake.recvArgsForCall = append(fake.recvArgsForCall, struct {
	}{})
	fake.recordInvocation("Recv", []interface{}{})
	fake.recvMutex.Unlock()
	if fake.RecvStub != nil {
		return fake.RecvStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.recvReturns
	return fakeReturns.result1, fakeReturns.result2
}

// RecvCallCount ...
func (fake *FakeSocket) RecvCallCount() int {
	fake.recvMutex.RLock()
	defer fake.recvMutex.RUnlock()
	return len(fake.recvArgsForCall)
}

// RecvCalls ...
func (fake *FakeSocket) RecvCalls(stub func() ([]byte, error)) {
	fake.recvMutex.Lock()
	defer fake.recvMutex.Unlock()
	fake.RecvStub = stub
}

// RecvReturns ...
func (fake *FakeSocket) RecvReturns(result1 []byte, result2 error) {
	fake.recvMutex.Lock()
	defer fake.recvMutex.Unlock()
	fake.RecvStub = nil
	fake.recvReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

// RecvReturnsOnCall ...
func (fake *FakeSocket) RecvReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.recvMutex.Lock()
	defer fake.recvMutex.Unlock()
	fake.RecvStub = nil
	if fake.recvReturnsOnCall == nil {
		fake.recvReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.recvReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

// RecvMsg ...
func (fake *FakeSocket) RecvMsg() (*mangos.Message, error) {
	fake.recvMsgMutex.Lock()
	ret, specificReturn := fake.recvMsgReturnsOnCall[len(fake.recvMsgArgsForCall)]
	fake.recvMsgArgsForCall = append(fake.recvMsgArgsForCall, struct {
	}{})
	fake.recordInvocation("RecvMsg", []interface{}{})
	fake.recvMsgMutex.Unlock()
	if fake.RecvMsgStub != nil {
		return fake.RecvMsgStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.recvMsgReturns
	return fakeReturns.result1, fakeReturns.result2
}

// RecvMsgCallCount ...
func (fake *FakeSocket) RecvMsgCallCount() int {
	fake.recvMsgMutex.RLock()
	defer fake.recvMsgMutex.RUnlock()
	return len(fake.recvMsgArgsForCall)
}

// RecvMsgCalls ...
func (fake *FakeSocket) RecvMsgCalls(stub func() (*mangos.Message, error)) {
	fake.recvMsgMutex.Lock()
	defer fake.recvMsgMutex.Unlock()
	fake.RecvMsgStub = stub
}

// RecvMsgReturns ...
func (fake *FakeSocket) RecvMsgReturns(result1 *mangos.Message, result2 error) {
	fake.recvMsgMutex.Lock()
	defer fake.recvMsgMutex.Unlock()
	fake.RecvMsgStub = nil
	fake.recvMsgReturns = struct {
		result1 *mangos.Message
		result2 error
	}{result1, result2}
}

// RecvMsgReturnsOnCall ...
func (fake *FakeSocket) RecvMsgReturnsOnCall(i int, result1 *mangos.Message, result2 error) {
	fake.recvMsgMutex.Lock()
	defer fake.recvMsgMutex.Unlock()
	fake.RecvMsgStub = nil
	if fake.recvMsgReturnsOnCall == nil {
		fake.recvMsgReturnsOnCall = make(map[int]struct {
			result1 *mangos.Message
			result2 error
		})
	}
	fake.recvMsgReturnsOnCall[i] = struct {
		result1 *mangos.Message
		result2 error
	}{result1, result2}
}

// Send ...
func (fake *FakeSocket) Send(arg1 []byte) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.sendMutex.Lock()
	ret, specificReturn := fake.sendReturnsOnCall[len(fake.sendArgsForCall)]
	fake.sendArgsForCall = append(fake.sendArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	fake.recordInvocation("Send", []interface{}{arg1Copy})
	fake.sendMutex.Unlock()
	if fake.SendStub != nil {
		return fake.SendStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sendReturns
	return fakeReturns.result1
}

// SendCallCount ...
func (fake *FakeSocket) SendCallCount() int {
	fake.sendMutex.RLock()
	defer fake.sendMutex.RUnlock()
	return len(fake.sendArgsForCall)
}

// SendCalls ...
func (fake *FakeSocket) SendCalls(stub func([]byte) error) {
	fake.sendMutex.Lock()
	defer fake.sendMutex.Unlock()
	fake.SendStub = stub
}

// SendArgsForCall ...
func (fake *FakeSocket) SendArgsForCall(i int) []byte {
	fake.sendMutex.RLock()
	defer fake.sendMutex.RUnlock()
	argsForCall := fake.sendArgsForCall[i]
	return argsForCall.arg1
}

// SendReturns ...
func (fake *FakeSocket) SendReturns(result1 error) {
	fake.sendMutex.Lock()
	defer fake.sendMutex.Unlock()
	fake.SendStub = nil
	fake.sendReturns = struct {
		result1 error
	}{result1}
}

// SendReturnsOnCall ...
func (fake *FakeSocket) SendReturnsOnCall(i int, result1 error) {
	fake.sendMutex.Lock()
	defer fake.sendMutex.Unlock()
	fake.SendStub = nil
	if fake.sendReturnsOnCall == nil {
		fake.sendReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

// SendMsg ...
func (fake *FakeSocket) SendMsg(arg1 *mangos.Message) error {
	fake.sendMsgMutex.Lock()
	ret, specificReturn := fake.sendMsgReturnsOnCall[len(fake.sendMsgArgsForCall)]
	fake.sendMsgArgsForCall = append(fake.sendMsgArgsForCall, struct {
		arg1 *mangos.Message
	}{arg1})
	fake.recordInvocation("SendMsg", []interface{}{arg1})
	fake.sendMsgMutex.Unlock()
	if fake.SendMsgStub != nil {
		return fake.SendMsgStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sendMsgReturns
	return fakeReturns.result1
}

// SendMsgCallCount ...
func (fake *FakeSocket) SendMsgCallCount() int {
	fake.sendMsgMutex.RLock()
	defer fake.sendMsgMutex.RUnlock()
	return len(fake.sendMsgArgsForCall)
}

// SendMsgCalls ...
func (fake *FakeSocket) SendMsgCalls(stub func(*mangos.Message) error) {
	fake.sendMsgMutex.Lock()
	defer fake.sendMsgMutex.Unlock()
	fake.SendMsgStub = stub
}

// SendMsgArgsForCall ...
func (fake *FakeSocket) SendMsgArgsForCall(i int) *mangos.Message {
	fake.sendMsgMutex.RLock()
	defer fake.sendMsgMutex.RUnlock()
	argsForCall := fake.sendMsgArgsForCall[i]
	return argsForCall.arg1
}

// SendMsgReturns ...
func (fake *FakeSocket) SendMsgReturns(result1 error) {
	fake.sendMsgMutex.Lock()
	defer fake.sendMsgMutex.Unlock()
	fake.SendMsgStub = nil
	fake.sendMsgReturns = struct {
		result1 error
	}{result1}
}

// SendMsgReturnsOnCall ...
func (fake *FakeSocket) SendMsgReturnsOnCall(i int, result1 error) {
	fake.sendMsgMutex.Lock()
	defer fake.sendMsgMutex.Unlock()
	fake.SendMsgStub = nil
	if fake.sendMsgReturnsOnCall == nil {
		fake.sendMsgReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendMsgReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

// SetOption ...
func (fake *FakeSocket) SetOption(arg1 string, arg2 interface{}) error {
	fake.setOptionMutex.Lock()
	ret, specificReturn := fake.setOptionReturnsOnCall[len(fake.setOptionArgsForCall)]
	fake.setOptionArgsForCall = append(fake.setOptionArgsForCall, struct {
		arg1 string
		arg2 interface{}
	}{arg1, arg2})
	fake.recordInvocation("SetOption", []interface{}{arg1, arg2})
	fake.setOptionMutex.Unlock()
	if fake.SetOptionStub != nil {
		return fake.SetOptionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setOptionReturns
	return fakeReturns.result1
}

// SetOptionCallCount ...
func (fake *FakeSocket) SetOptionCallCount() int {
	fake.setOptionMutex.RLock()
	defer fake.setOptionMutex.RUnlock()
	return len(fake.setOptionArgsForCall)
}

// SetOptionCalls ...
func (fake *FakeSocket) SetOptionCalls(stub func(string, interface{}) error) {
	fake.setOptionMutex.Lock()
	defer fake.setOptionMutex.Unlock()
	fake.SetOptionStub = stub
}

// SetOptionArgsForCall ...
func (fake *FakeSocket) SetOptionArgsForCall(i int) (string, interface{}) {
	fake.setOptionMutex.RLock()
	defer fake.setOptionMutex.RUnlock()
	argsForCall := fake.setOptionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

// SetOptionReturns ...
func (fake *FakeSocket) SetOptionReturns(result1 error) {
	fake.setOptionMutex.Lock()
	defer fake.setOptionMutex.Unlock()
	fake.SetOptionStub = nil
	fake.setOptionReturns = struct {
		result1 error
	}{result1}
}

// SetOptionReturnsOnCall ...
func (fake *FakeSocket) SetOptionReturnsOnCall(i int, result1 error) {
	fake.setOptionMutex.Lock()
	defer fake.setOptionMutex.Unlock()
	fake.SetOptionStub = nil
	if fake.setOptionReturnsOnCall == nil {
		fake.setOptionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setOptionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

// SetPipeEventHook ...
func (fake *FakeSocket) SetPipeEventHook(arg1 mangos.PipeEventHook) mangos.PipeEventHook {
	fake.setPipeEventHookMutex.Lock()
	ret, specificReturn := fake.setPipeEventHookReturnsOnCall[len(fake.setPipeEventHookArgsForCall)]
	fake.setPipeEventHookArgsForCall = append(fake.setPipeEventHookArgsForCall, struct {
		arg1 mangos.PipeEventHook
	}{arg1})
	fake.recordInvocation("SetPipeEventHook", []interface{}{arg1})
	fake.setPipeEventHookMutex.Unlock()
	if fake.SetPipeEventHookStub != nil {
		return fake.SetPipeEventHookStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setPipeEventHookReturns
	return fakeReturns.result1
}

// SetPipeEventHookCallCount ...
func (fake *FakeSocket) SetPipeEventHookCallCount() int {
	fake.setPipeEventHookMutex.RLock()
	defer fake.setPipeEventHookMutex.RUnlock()
	return len(fake.setPipeEventHookArgsForCall)
}

// SetPipeEventHookCalls ...
func (fake *FakeSocket) SetPipeEventHookCalls(stub func(mangos.PipeEventHook) mangos.PipeEventHook) {
	fake.setPipeEventHookMutex.Lock()
	defer fake.setPipeEventHookMutex.Unlock()
	fake.SetPipeEventHookStub = stub
}

// SetPipeEventHookArgsForCall ...
func (fake *FakeSocket) SetPipeEventHookArgsForCall(i int) mangos.PipeEventHook {
	fake.setPipeEventHookMutex.RLock()
	defer fake.setPipeEventHookMutex.RUnlock()
	argsForCall := fake.setPipeEventHookArgsForCall[i]
	return argsForCall.arg1
}

// SetPipeEventHookReturns ...
func (fake *FakeSocket) SetPipeEventHookReturns(result1 mangos.PipeEventHook) {
	fake.setPipeEventHookMutex.Lock()
	defer fake.setPipeEventHookMutex.Unlock()
	fake.SetPipeEventHookStub = nil
	fake.setPipeEventHookReturns = struct {
		result1 mangos.PipeEventHook
	}{result1}
}

// SetPipeEventHookReturnsOnCall ...
func (fake *FakeSocket) SetPipeEventHookReturnsOnCall(i int, result1 mangos.PipeEventHook) {
	fake.setPipeEventHookMutex.Lock()
	defer fake.setPipeEventHookMutex.Unlock()
	fake.SetPipeEventHookStub = nil
	if fake.setPipeEventHookReturnsOnCall == nil {
		fake.setPipeEventHookReturnsOnCall = make(map[int]struct {
			result1 mangos.PipeEventHook
		})
	}
	fake.setPipeEventHookReturnsOnCall[i] = struct {
		result1 mangos.PipeEventHook
	}{result1}
}

// Invocations ...
func (fake *FakeSocket) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.dialMutex.RLock()
	defer fake.dialMutex.RUnlock()
	fake.dialOptionsMutex.RLock()
	defer fake.dialOptionsMutex.RUnlock()
	fake.getOptionMutex.RLock()
	defer fake.getOptionMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.listenMutex.RLock()
	defer fake.listenMutex.RUnlock()
	fake.listenOptionsMutex.RLock()
	defer fake.listenOptionsMutex.RUnlock()
	fake.newDialerMutex.RLock()
	defer fake.newDialerMutex.RUnlock()
	fake.newListenerMutex.RLock()
	defer fake.newListenerMutex.RUnlock()
	fake.openContextMutex.RLock()
	defer fake.openContextMutex.RUnlock()
	fake.recvMutex.RLock()
	defer fake.recvMutex.RUnlock()
	fake.recvMsgMutex.RLock()
	defer fake.recvMsgMutex.RUnlock()
	fake.sendMutex.RLock()
	defer fake.sendMutex.RUnlock()
	fake.sendMsgMutex.RLock()
	defer fake.sendMsgMutex.RUnlock()
	fake.setOptionMutex.RLock()
	defer fake.setOptionMutex.RUnlock()
	fake.setPipeEventHookMutex.RLock()
	defer fake.setPipeEventHookMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSocket) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ mangos.Socket = new(FakeSocket)
